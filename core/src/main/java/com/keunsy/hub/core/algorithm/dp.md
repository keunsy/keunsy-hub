### DP()dynamic programming)

### 参考地址
- http://blog.csdn.net/sun897949163/article/details/52077460

#### DP 是一种编程思想，主要用于解决最优解类型的问题。

#### 使用dp的问题一般满足下面的两个特征
1. 最优子结构，就是指问题可以通过子问题最优解得到；体现为找出所有的子问题最优解，然后取其中的最优；
2. 重叠子问题，就是子问题是会重复的。而不是一直产生新的子问题（比如分治类型的问题）。
3. 无后效性：这是DP中最重要的一点，他要求每个子问题的决策不能对后面其他未解决的问题产影响， 如果产生就无法保证决策的最优性， 这就是无后效性。往往需要我们找到一个合适的状态。 

#### DP在算法上的形式

1. 自顶向下，就是直接从原问题入手，不断利用子问题来求解，这种写法是一个递归地形式，
但是需要加入备忘录，就是说利用一个数组存已经算出的子问题的结果，下次遇到直接返回。
这个思路叫做memoization，备忘录。是一种空间换时间的做法，因为某些子问题会被调用到很多次，
如果使用memo，那么时间上会很高效。比如求斐波那契数列，几乎每一个求解都会用到f(2)这样的子问题，
如果事先存好，那么时间复杂度会下降很多。还有一点，memo不是为dp而生的，它也是一种思想或者技巧，
在递归或者dfs中可以使用，如果要求时间复杂度可以考虑使用memo。

2. 自底向上，这种不需要递归，就是不断地计算出小问题的解，然后后面的问题就可以利用小问题的解得到。

#### 常用的解题步骤
1. 确定子问题。 在这一步重点是分析那些变量是随着问题规模的变小而变小的， 那些变量与问题的规模无关。 
2. 确定状态：根据上面找到的子问题来给你分割的子问题限定状态 
3. 推到出状态转移方程：这里要注意你的状态转移方程是不是满足所有的条件， 注意不要遗漏。 
4. 确定边界条件：先根据题目的限制条件来确定题目中给出的边界条件是否能直接推导出， 如果不行也可以尝试从边界条件反推（举个例子：a(n)→a(2)有递推关系， 但是a(2)→a(1)不符合上述递推关系， 我们就可以考虑用a(1)来倒推出a(2)， 然后将递推的终点设置为a(2)）; 
5. 确定实现方式：这个依照个人习惯 就像是01背包的两层for循环的顺序 
6. 确定优化方法：很多时候你会发现走到这里步的时候你需要返回第1步重来。首先考虑降维问题（优化内存）， 优先队列、四边形不等式（优化时间）等等。


